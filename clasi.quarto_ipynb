{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Midterm 2\"\n",
        "jupyter: python3\n",
        "author: \"Paul C \"\n",
        "date: \"10-04-2025\"\n",
        "format: \n",
        "    html:\n",
        "        embed-resources: true\n",
        "---\n"
      ],
      "id": "1133fc70"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.linear_model import LogisticRegression\n",
        "from sklearn.pipeline import Pipeline\n",
        "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay, classification_report\n",
        "from sklearn.preprocessing import LabelEncoder\n",
        "import matplotlib.pyplot as plt\n",
        "import warnings\n",
        "warnings.filterwarnings('ignore')"
      ],
      "id": "b9533aa3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Carga de dataset\n"
      ],
      "id": "dbe82e09"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 1. CARGAR DATASET\n",
        "print(\"=\"*70)\n",
        "print(\"CLASIFICACIÓN DE CANCHAS - REGRESIÓN LOGÍSTICA\")\n",
        "print(\"=\"*70)\n",
        "\n",
        "try:\n",
        "    df = pd.read_csv('canchas.csv', sep=';', encoding='utf-8-sig')\n",
        "except:\n",
        "    df = pd.read_csv('canchas.csv', sep=';', encoding='latin-1')\n",
        "\n",
        "df.columns = df.columns.str.strip().str.replace('ï»¿', '')\n",
        "df = df.loc[:, df.columns != '']\n",
        "df = df.loc[:, ~df.columns.str.match('^Unnamed')]\n",
        "\n",
        "print(f\"Total de registros: {len(df)}\")"
      ],
      "id": "c1f03d3f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Variable objetivo\n"
      ],
      "id": "c4d48634"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 2. VARIABLE OBJETIVO\n",
        "costo_col = 'Costo por uso de las instalaciones'\n",
        "df[costo_col] = pd.to_numeric(df[costo_col], errors='coerce')\n",
        "df['tiene_costo'] = (df[costo_col] > 0).astype(int)\n",
        "\n",
        "print(\"\\n\" + \"=\"*70)\n",
        "print(\"DISTRIBUCIÓN DE CLASES\")\n",
        "print(\"=\"*70)\n",
        "dist = df['tiene_costo'].value_counts().sort_index()\n",
        "total = dist.sum()\n",
        "print(f\"Gratis (0):    {dist.get(0, 0):3d} canchas ({dist.get(0, 0)/total*100:5.2f}%)\")\n",
        "print(f\"Con costo (1): {dist.get(1, 0):3d} canchas ({dist.get(1, 0)/total*100:5.2f}%)\")\n",
        "print(f\"\\nDesbalanceo de clases: {dist.get(0, 0)/dist.get(1, 0):.2f}:1\")"
      ],
      "id": "fcf8a25b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Seleccion de features\n"
      ],
      "id": "71b98eb4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 3. SELECCIONAR FEATURES\n",
        "features_map = {\n",
        "    'zonal': None, 'provincia': None, 'canton': None, 'estado': None,\n",
        "    'cubierta': None, 'propiedad': None, 'uso': None\n",
        "}\n",
        "\n",
        "for col in df.columns:\n",
        "    col_norm = col.lower().replace('á', 'a').replace('é', 'e').replace('í', 'i').replace('ó', 'o').replace('ú', 'u')\n",
        "    if 'zonal' in col_norm or 'coordinacion' in col_norm:\n",
        "        features_map['zonal'] = col\n",
        "    elif 'provincia' in col_norm:\n",
        "        features_map['provincia'] = col\n",
        "    elif 'canton' in col_norm:\n",
        "        features_map['canton'] = col\n",
        "    elif 'estado' in col_norm:\n",
        "        features_map['estado'] = col\n",
        "    elif 'cubierta' in col_norm or 'caracteristica' in col_norm:\n",
        "        features_map['cubierta'] = col\n",
        "    elif 'propiedad' in col_norm and 'tipo' in col_norm:\n",
        "        features_map['propiedad'] = col\n",
        "    elif 'uso' in col_norm and 'escenario' in col_norm:\n",
        "        features_map['uso'] = col\n",
        "\n",
        "features = [v for v in features_map.values() if v is not None]\n",
        "\n",
        "print(\"\\n\" + \"=\"*70)\n",
        "print(\"FEATURES SELECCIONADAS\")\n",
        "print(\"=\"*70)\n",
        "for i, feat in enumerate(features, 1):\n",
        "    n_unique = df[feat].nunique()\n",
        "    print(f\"{i}. {feat}: {n_unique} categorías\")"
      ],
      "id": "1404e290",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Preparar datos\n"
      ],
      "id": "054b3d7e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "datos_validos = df[df['tiene_costo'].notna()]\n",
        "df_model = datos_validos[features + ['tiene_costo']].copy()\n",
        "\n",
        "for col in features:\n",
        "    df_model[col] = df_model[col].fillna('Desconocido')\n",
        "\n",
        "df_model = df_model.drop_duplicates()\n",
        "print(f\"\\nDatos finales: {len(df_model)} registros ({len(df_model)/len(df)*100:.1f}% del total)\")\n",
        "\n",
        "\n",
        "\n",
        "# 5. CODIFICAR\n",
        "encoders = {}\n",
        "for col in features:\n",
        "    le = LabelEncoder()\n",
        "    df_model[col] = le.fit_transform(df_model[col].astype(str))\n",
        "    encoders[col] = le\n",
        "\n",
        "X = df_model[features].values\n",
        "y = df_model['tiene_costo'].values\n",
        "\n",
        "# 6. SPLIT\n",
        "X_train, X_test, y_train, y_test = train_test_split(\n",
        "    X, y, test_size=0.2, random_state=42, stratify=y\n",
        ")\n",
        "\n",
        "print(\"\\n\" + \"=\"*70)\n",
        "print(\"DIVISIÓN DE DATOS\")\n",
        "print(\"=\"*70)\n",
        "print(f\"Train: {len(X_train)} muestras (Gratis: {(y_train==0).sum()}, Con costo: {(y_train==1).sum()})\")\n",
        "print(f\"Test:  {len(X_test)} muestras (Gratis: {(y_test==0).sum()}, Con costo: {(y_test==1).sum()})\")\n"
      ],
      "id": "8d7e6f74",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Pipeline\n"
      ],
      "id": "10fddde6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 7. PIPELINE CON REGRESIÓN LOGÍSTICA\n",
        "print(\"\\n\" + \"=\"*70)\n",
        "print(\"ENTRENANDO MODELO\")\n",
        "print(\"=\"*70)\n",
        "\n",
        "pipe = Pipeline([\n",
        "    ('escalado', StandardScaler()),\n",
        "    ('logreg', LogisticRegression(\n",
        "        max_iter=100000,\n",
        "        random_state=42,\n",
        "        class_weight='balanced'  # Maneja el desbalanceo de clases\n",
        "    ))\n",
        "])\n",
        "\n",
        "print(\"Entrenando Regresión Logística con class_weight='balanced'...\")\n",
        "pipe.fit(X_train, y_train)\n",
        "print(\"✓ Modelo entrenado exitosamente\\n\")"
      ],
      "id": "d515f30c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Predicciones\n"
      ],
      "id": "6caebbf6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 8. PREDICCIONES\n",
        "y_pred_train = pipe.predict(X_train)\n",
        "y_pred_test = pipe.predict(X_test)\n"
      ],
      "id": "aceac33b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Evaluacion\n"
      ],
      "id": "d172a169"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"=\"*70)\n",
        "print(\"RESULTADOS - CONJUNTO DE ENTRENAMIENTO\")\n",
        "print(\"=\"*70)\n",
        "acc_train = accuracy_score(y_train, y_pred_train)\n",
        "prec_train = precision_score(y_train, y_pred_train, zero_division=0)\n",
        "rec_train = recall_score(y_train, y_pred_train, zero_division=0)\n",
        "f1_train = f1_score(y_train, y_pred_train, zero_division=0)\n",
        "\n",
        "print(f\"Accuracy:  {acc_train:.4f} ({acc_train*100:.2f}%)\")\n",
        "print(f\"Precision: {prec_train:.4f} ({prec_train*100:.2f}%)\")\n",
        "print(f\"Recall:    {rec_train:.4f} ({rec_train*100:.2f}%)\")\n",
        "print(f\"F1-Score:  {f1_train:.4f} ({f1_train*100:.2f}%)\")"
      ],
      "id": "7c4c7fcd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Evaluacion\n"
      ],
      "id": "7e41cbf0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 10. EVALUACIÓN - TEST\n",
        "print(\"\\n\" + \"=\"*70)\n",
        "print(\"RESULTADOS - CONJUNTO DE PRUEBA\")\n",
        "print(\"=\"*70)\n",
        "acc_test = accuracy_score(y_test, y_pred_test)\n",
        "prec_test = precision_score(y_test, y_pred_test, zero_division=0)\n",
        "rec_test = recall_score(y_test, y_pred_test, zero_division=0)\n",
        "f1_test = f1_score(y_test, y_pred_test, zero_division=0)"
      ],
      "id": "cd4b02e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Evaluacion del modelo\n"
      ],
      "id": "a69b4c60"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diferencia = abs(acc_train - acc_test)"
      ],
      "id": "689fd261",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Visualizaciones\n",
        "Visualizaremos la matriz de confucion"
      ],
      "id": "a1a2f234"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "\n",
        "ConfusionMatrixDisplay.from_predictions(\n",
        "    y_test, y_pred_test,\n",
        "    display_labels=['Gratis', 'Con Costo'],\n",
        "    cmap='Blues',\n",
        "    ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f'Matriz de Confusión\\nAccuracy: {acc_test*100:.1f}%', \n",
        "                 fontsize=12, fontweight='bold')\n",
        "\n",
        "# Comparación de métricas Train vs Test\n",
        "metricas = ['Accuracy', 'Precision', 'Recall', 'F1-Score']\n",
        "valores_train = [acc_train, prec_train, rec_train, f1_train]\n",
        "valores_test = [acc_test, prec_test, rec_test, f1_test]\n",
        "\n",
        "x = np.arange(len(metricas))\n",
        "width = 0.35\n",
        "\n",
        "axes[1].bar(x - width/2, valores_train, width, label='Train', color='lightcoral', alpha=0.7)\n",
        "axes[1].bar(x + width/2, valores_test, width, label='Test', color='steelblue', alpha=0.7)\n",
        "axes[1].set_xlabel('Métricas', fontsize=11)\n",
        "axes[1].set_ylabel('Score', fontsize=11)\n",
        "axes[1].set_title('Comparación Train vs Test', fontweight='bold', fontsize=12)\n",
        "axes[1].set_xticks(x)\n",
        "axes[1].set_xticklabels(metricas, rotation=45, ha='right')\n",
        "axes[1].legend()\n",
        "axes[1].grid(axis='y', alpha=0.3)\n",
        "axes[1].set_ylim([0, 1.1])\n",
        "\n",
        "# Agregar valores en las barras\n",
        "for i, v in enumerate(valores_train):\n",
        "    axes[1].text(i - width/2, v + 0.02, f'{v:.2f}', ha='center', va='bottom', fontsize=9)\n",
        "for i, v in enumerate(valores_test):\n",
        "    axes[1].text(i + width/2, v + 0.02, f'{v:.2f}', ha='center', va='bottom', fontsize=9)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ],
      "id": "151f8ad2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### ROC, DISTRIBUCION DE CLASES Y  CURVA (GRAFICAS)\n",
        "    Se usara altair para es despliegue de estas graficas"
      ],
      "id": "3fabfd5c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from sklearn.metrics import roc_curve, auc\n",
        "\n",
        "y_proba_test = pipe.predict_proba(X_test)[:, 1]\n",
        "\n",
        "\n",
        "fpr, tpr, thresholds = roc_curve(y_test, y_proba_test)\n",
        "roc_auc = auc(fpr, tpr)\n",
        "\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "ax1 = axes[0]\n",
        "clases = ['Gratis (0)', 'Con Costo (1)']\n",
        "valores = [dist.get(0, 0), dist.get(1, 0)]\n",
        "colores = ['#3498db', '#e74c3c']\n",
        "\n",
        "bars = ax1.bar(clases, valores, color=colores, alpha=0.7, edgecolor='black', linewidth=1.5)\n",
        "ax1.set_ylabel('Cantidad de Canchas', fontsize=11, fontweight='bold')\n",
        "ax1.set_title('Distribución de Clases en el Dataset', fontsize=12, fontweight='bold')\n",
        "ax1.grid(axis='y', alpha=0.3, linestyle='--')\n",
        "\n",
        "for bar, val in zip(bars, valores):\n",
        "    height = bar.get_height()\n",
        "    ax1.text(bar.get_x() + bar.get_width()/2., height,\n",
        "            f'{val}\\n({val/total*100:.1f}%)',\n",
        "            ha='center', va='bottom', fontsize=10, fontweight='bold')\n",
        "\n",
        "ratio = dist.get(0, 0) / dist.get(1, 0)\n",
        "ax1.text(0.5, max(valores)*0.9, f'Ratio de desbalanceo: {ratio:.1f}:1', \n",
        "         ha='center', fontsize=10, style='italic',\n",
        "         bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n",
        "\n",
        "ax2 = axes[1]\n",
        "ax2.plot(fpr, tpr, color='#2ecc71', linewidth=2, label=f'ROC (AUC = {roc_auc:.3f})')\n",
        "ax2.plot([0, 1], [0, 1], color='gray', linestyle='--', linewidth=1.5, label='Azar (AUC = 0.500)')\n",
        "ax2.set_xlim([0.0, 1.0])\n",
        "ax2.set_ylim([0.0, 1.05])\n",
        "ax2.set_xlabel('Tasa de Falsos Positivos (FPR)', fontsize=11, fontweight='bold')\n",
        "ax2.set_ylabel('Tasa de Verdaderos Positivos (TPR)', fontsize=11, fontweight='bold')\n",
        "ax2.set_title('Curva ROC - Regresión Logística', fontsize=12, fontweight='bold')\n",
        "ax2.legend(loc='lower right', fontsize=10)\n",
        "ax2.grid(alpha=0.3, linestyle='--')\n",
        "\n",
        "ax2.fill_between(fpr, tpr, alpha=0.2, color='#2ecc71')"
      ],
      "id": "247b6b46",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Se puede observar como la canchas publicas tienen al mayor cantidad a diferencia de canchas con costo; los resultados reflejan la realidad, una mejor cantidad de datos nos podrian ser util para mejorar el modelo. "
      ],
      "id": "407467bd"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "c:\\Users\\pcstu\\OneDrive\\Documentos\\MIA\\ML\\Semana 1\\ml1\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}